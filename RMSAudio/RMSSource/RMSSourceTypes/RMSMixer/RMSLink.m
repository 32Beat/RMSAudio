////////////////////////////////////////////////////////////////////////////////
/*
	RMSLink
	
	Created by 32BT on 15/11/15.
	Copyright Â© 2015 32BT. All rights reserved.
*/
////////////////////////////////////////////////////////////////////////////////


#import "RMSLink.h"
#import "RMSUtilities.h"
#import "RMSAudio.h"


@interface RMSLink ()
{
	RMSLink *mLink;

	RMSLink *mTrash;
	void *mTrashSeen;
	
	BOOL mTrashUpdatePending;
}
@end


////////////////////////////////////////////////////////////////////////////////
@implementation RMSLink
////////////////////////////////////////////////////////////////////////////////
#pragma mark
#pragma mark Trash Management
////////////////////////////////////////////////////////////////////////////////

- (void) trashObject:(id)object
{
	if (object != nil)
	{ [self insertTrash:object]; }
	[self updateTrash];
}

////////////////////////////////////////////////////////////////////////////////

- (void) insertTrash:(id)object
{
	if (mTrash != nil)
	{ [object insertTrash:mTrash]; }
	mTrash = object;
}

////////////////////////////////////////////////////////////////////////////////

- (void) removeTrash:(void *)object
{
	if (mTrash == object)
	{ mTrash = nil; }
	else
	{ [mTrash removeTrash:object]; }
}

////////////////////////////////////////////////////////////////////////////////

- (void) updateTrash
{
	if (mTrashSeen != nil)
	{
		[self removeTrash:mTrashSeen];
		mTrashSeen = nil;
	}
	
	// Try emptying more trash later if necessary
	if (mTrash != nil)
	{ [self triggerTrashUpdate]; }
}

////////////////////////////////////////////////////////////////////////////////

- (void) triggerTrashUpdate
{
	if (mTrashUpdatePending == NO)
	{
		mTrashUpdatePending = YES;
		dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1.0e+8);
		dispatch_after(time, dispatch_get_main_queue(),
		^{
			mTrashUpdatePending = NO;
			[self updateTrash];
		});
	}
}

////////////////////////////////////////////////////////////////////////////////
#pragma mark
////////////////////////////////////////////////////////////////////////////////
// macro for condensed, unmanaged access
// for use by the audiothread
#define RMSLinkBridge(objectPtr) \
((__bridge __unsafe_unretained RMSLink *)(objectPtr))
////////////////////////////////////////////////////////////////////////////////

void *RMSLinkGetLink(void *linkPtr)
{ return (__bridge void *)RMSLinkBridge(linkPtr)->mLink; }

void RMSLinkUpdateTrash(void *linkPtr)
{
	__unsafe_unretained RMSLink *link =
	(__bridge __unsafe_unretained RMSLink *)linkPtr;

	if (link != nil && link->mTrash != nil)
	{
		if (link->mTrashSeen == nil)
		{
			link->mTrashSeen = (__bridge void *)link->mTrash;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
#pragma mark
////////////////////////////////////////////////////////////////////////////////

- (void) dealloc
{
	NSLog(@"%@", self);
}

////////////////////////////////////////////////////////////////////////////////

- (id) link
{ return mLink; }

////////////////////////////////////////////////////////////////////////////////

- (void) setLink:(RMSLink *)link
{
	if (mLink != link)
	{
		id trash = mLink;
		mLink = link;
		[self trashObject:trash];
	}
}

////////////////////////////////////////////////////////////////////////////////

- (void) addLink:(RMSLink *)link
{
	if (mLink == nil)
	{ mLink = link; }
	else
	{ [mLink addLink:link]; }
}

////////////////////////////////////////////////////////////////////////////////

- (void) insertLink:(RMSLink *)link
{
	if (mLink != nil)
	{ [link addLink:mLink]; }
	mLink = link;
}

////////////////////////////////////////////////////////////////////////////////

- (void) removeLink:(RMSLink *)link
{
	if (mLink == link)
	{ [self removeLink]; }
	else
	{ [mLink removeLink:link]; }
}

////////////////////////////////////////////////////////////////////////////////

- (void) removeLink
{
	if (mLink != nil)
	{ [self setLink:[mLink link]]; }
}

////////////////////////////////////////////////////////////////////////////////

- (id) linkAtIndex:(UInt32)index
{
	RMSLink *link = self.link;
	UInt32 n = 0;
	
	while (link != nil && n != index)
	{
		link = link.link;
		n += 1;
	}
	
	return link;
}

////////////////////////////////////////////////////////////////////////////////

- (void) iterateLinksUsingBlock:(void (^)(RMSLink *link))blockPtr
{
	RMSLink *link = self.link;
	while (link != nil)
	{
		blockPtr(link);
		link = link.link;
	}
}

////////////////////////////////////////////////////////////////////////////////
@end
////////////////////////////////////////////////////////////////////////////////
